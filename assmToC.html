<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html  PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN'  'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'><html xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/> 
    <title>Writing an OS from Scratch: Jumping from a Bootloader to C Code</title>
    <link href="index.rss" rel="alternate" title="RSS" type="application/rss+xml"/> 
    <style type="text/css">
    a:link { color: #293145; border-bottom: solid thin #293145; }
    a:visited { color: #666; border-bottom: dotted thin #666; }
    a:hover { color: #666; border-bottom: dotted thin #666; }
    a:active { color: #fff; border-bottom: none; }
    a { text-decoration: none; }
    
    body {
        margin-top: 50px;
        margin-bottom: 20px;
        margin-left: auto;
        margin-right: auto;
        min-width: 50em;
        max-width: 750px; 
        font-family: Georgia, Cambria, 'Times New Roman', Times, serif;
        font-size: 20px;
        line-height: 1.4;
    }
    
    h2, h3, .heading, .name {
        color: #293145;
        font-family: Arial, sans-serif;
    }
    
    .heading, .name {
        margin: 0;
        text-align: right;
    }
    
    .name {
        font-size: 250%;
        font-weight: bold;
    }
    
    .me {
        font-weight: bold;
        font-style: inherit;
    }
    
    .bibliography {
        margin-left: 2em;
        text-indent: -2em;
    }
    
    .sideNote {
        background-color: #d2d6fa;
        
        border-radius: 15px;
        border-style: solid;
        border-width: 5px;
        border-color: black;
        
        box-shadow: 5px 5px rgba(0, 26, 98, 0.4),
                  10px 10px rgba(0, 26, 98, 0.3),
                  15px 15px rgba(0, 26, 98, 0.2),
                  20px 20px rgba(0, 26, 98, 0.1),
                  25px 25px rgba(0, 26, 98, 0.05);
    
    }
    
    .sideNote p {
        padding-left: 1em;
        padding-right: 1em;
    }
    
    img {
        max-width: 90%;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }
    
    .citation {
        list-style-type: none;
    }

    .code_file {
        /* max-width: 1500px */
        width: 100%;
        max-width: 100%;
        display: block;
        margin-left: auto;
        margin-right: auto;
        float: center
    }

    .code_block {
        max-width: 90%;
        display: block;
        margin-left: auto;
        margin-right: auto;
        background-color: #f9f9f9;
        border: 1px dashed #2f6fab;
    }

    .source_code {
        font-family: monospace,Courier !important;
        display: inline-block;
        font-size: 20px;
    }
    
    </style>
    </head>
        
    <body>

    <div style="float: left; padding-top: 10px; padding-bottom: 10px;">
    <p class="name">Writing an OS from Scratch: Jumping from a Bootloader to C Code</p>
    <p class="heading"><a href="index.html">home</a>
    </div>
    <br clear="all"/>
    </div>
    <div style="padding: 10px;">

    <h3>05/09/2021</h3>
    <ul>
        <li><a href="#intro">Introduction</a></li>
        <li><a href="#bootloader">A Bare-Bones Bootloader</a></li>
        <li><a href="#compileTools">GCC Cross-Compiler</a></li>
        <li><a href="#linker">Writing a Linker Script</a></li>
        <li><a href="#loading">Loading Our Kernel into Memory</a></li>
        <li><a href="#gdb">Using GDB to Make Sure Things Worked</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
        <li><a href="#referenceHeader">References</a></li>

    </ul>

    <br><br>
    <h2 id="intro"> Introduction </h2>

    <p>
        This post is for anyone that wants to learn more about operating systems and that may even be trying to write their own, as I am.  
    </p>

    <p>
        When I started writing my own OS for x86 (IA-32), I found plenty of online tutorials for how to write my own bootloader (a Google search for "how to write your own bootloader"
        returns 845,000 results).  But I wasn't sure where to go once I had a bootloader that entered protected mode and printed "Hello World" to the screen.
        What I really wanted to do was take my operating system from a single assembly file to an organized project consisting of C code.    
    </p>

    <p>
        It turns out that making the jump from a bare-bones bootloader to C code isn't too complicated of a process; I'll do my best to show you how I went about doing this.
        I'll start by giving a quick overview of my initial bootloader and project setup.  Next, I'll help you configure a cross-compiler, which will let you compile C code for 
        your generic operating system.  Next, we'll write some C code, and use our cross-compiler along with a custom linker script to generate a binary.  
        Finally, we'll write assembly code to load our new binary into memory and start executing it.
    </p>

    <br><br>
    <h2 id="bootloader"> A Bare-Bones Bootloader </h2>

    <p>
        If you don't already have a simple assembly bootloader, there are a ton of great tutorials online on how to write one.
        <a href="http://3zanders.co.uk/2017/10/13/writing-a-bootloader/">Here's one by Alex Parker (3zanders.co.uk) that I enjoyed.</a>
        In short, your bootloader should be detectable by the BIOS and should transition the CPU from real mode to protected mode.  
        It's ok if it doesn't do the "loading" part of 
        bootloading yet; I'll show you how to load your kernel into memory later.
    </p>

    <p>
        <a href="https://github.com/RyanStan/ConiferOS/tree/6d21f67ca3e3c94756e4f01ae83e187660186e55">Here was the initial structure of my project.</a>

        <br> <br>
        <img src="images/assmToC/initialStructure.PNG">
        <br> <br>

        Let's take a look at the Makefile since it shows the tools I'm using to run my project.
        
        <br> <br>
        <img src="images/assmToC/initialMakefile.PNG">
        <br> <br>

        The goal is <span class="source_code">bin/disk.img</span>.  This file is used by <a href="https://www.qemu.org/">QEMU</a> as the virtual hard drive raw disk image.
        For now, this file is an exact copy of <span class="source_code">bin/boot.bin</span> which is created when I assemble <span class="source_code">src/boot/boot.asm</span></a>.
        
        I'm using <a href="https://www.nasm.us/">NASM</a> which is an assembler for the x86 architecture (it uses Intel syntax as opposed to AT&T).
        By passing <span class="source_code">-f bin</span> to nasm, I'm making sure that the assembler outputs a pure binary file.
        <br> <br>

        The run target uses QEMU to emulate an x86 machine booting up with <span class="source_code">bin/disk.img</span> 
        <a href="https://qemu-project.gitlab.io/qemu/system/invocation.html"> as the virtual hard drive raw disk image.</a>
        Later in this post, you may notice that I switch to using <span class="source_code">qemu-system-i386</span> instead of <span class="source_code">qemu-system-x86_64</span>. 
        The former is targeted for 32-bit x86 architectures while the latter is targeted for 64-bit x86 architectures.  While this won't make a difference in this post,
        later on you could run into trouble writing 32-bit code while using the 64-bit emulator.

        <br><br>
        Now let's take a look at <a href="https://github.com/RyanStan/ConiferOS/blob/cd53f9d8fd7dae329bcf0f2afb3f479de04580f4/src/boot/boot.asm"><span class="source_code">src/boot/boot.asm</span></a>
        so you have an idea of what the disk image will initially contain when passed to QEMU.  I'd like to preface this code by mentioning that 
        I used <a href="https://www.udemy.com/course/developing-a-multithreaded-kernel-from-scratch/">Daniel McCarthy's Operating System course</a> on Udemy as a guide when writing it (which I highly recommend).
        
        <br><br>
        <img class="code_file" src="images/assmToC/boot_asm_0.png">
        <br> <br>

        I made sure to heavily comment this assembly code so it's easier to understand.
        I want to point out that no matter how you write your initial disk image / bootloader (or which tutorial you use), your 
        disk image must be exactly 512 bytes so that it fits into one <a href="https://en.wikipedia.org/wiki/Disk_sector">sector</a>
        and the last two bytes (the boot signature) must be 0x55AA so that the BIOS knows this is a boot sector and can 
        load it into memory at 0x0000:0x7c00 (segment 0, address 0x7c00) [1].

        <br> <br>
        
        My bootloader does a few important things:
        <ul>
            <li>Sets the segmentation registers</li>
            <li>Initializes the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">GDT</a></li>
            <li>Enables <a href="https://wiki.osdev.org/Protected_Mode">protected mode</a></li>
            <li>Sets the stack and base pointers</li>
            <li>Enables the <a href="https://wiki.osdev.org/A20_Line">A20 line</a></li>
        </ul>

        If you want to dive deeper into my bootloader, I highly recommend browsing <a href="https://wiki.osdev.org/Expanded_Main_Page">OSDev.org</a>;  
         They have a great section on booting and setup.  Or, make sure to check out the Udemy course that I mentioned earlier.  

        <br><br>

    </p>

    <br><br>
    <h2 id="compileTools"> GCC Cross-Compiler </h2>

    <p>
        Unfortunately, we can't just use GCC (as it is) to compile our future C code.  To see why this is, go to your terminal and type the command 
        <span class="source_code">gcc -dumpmachine</span>.
        <br><br>
        <img src="images/assmToC/gccVersion.PNG">
        <br><br>
        This command prints the compiler's target platform.  In my case, the target is 'x86_64-linux-gnu.'  By default, GCC generates
        executables for the same platform that it itself was compiled on.  This isn't what we want; we need to make sure that GCC generates 
        executables for a generic target so that it doesn't try using any Linux libraries or headers that we haven't yet implemented for our OS [3].
        <br><br>

        In the case of my operating system, I'm going to build a compiler with the generic target 'i686-elf.'  This is a bare target meant 
        for freestanding programs on x86 32-bit machines.  For some other bare targets and an explanation of target triplets, check out this 
        <a href=https://wiki.osdev.org/Target_Triplet>OSDev article</a> on target triplets.

        <br><br>

        Before installing GCC, you'll have to download all the dependencies.  Here's a helpful screenshot from another <a href="https://wiki.osdev.org/GCC_Cross-Compiler">OSDev article on cross-compilers</a>
        on building a cross-compiler.

        <br><br>
        <img src="images/assmToC/installingDepsGCC.PNG">
        [2]
        <br><br>

       Next, you'll have to download, configure, and build Binutils, another dependency of GCC.  Unfortunately, 
       we can't install Binutils through a package manager since we have to configure all the tools to have the same target platform 
       as our cross-compiler (i686-elf).  
       
       There are three important tools that Binutils provides [4]:

       <ul>
           <li><b>ld</b> - the GNU linker</li>
           <li><b>as</b> - the GNU assembler </li>
           <li><b>ar</b> - a program which can manipulate linker libraries into the target machine's format</li>
           <li><b>ranlib</b> - generates an inded to the contents of an archive</li>
       </ul>
       Download the source code for Binutils from <a href="https://ftpmirror.gnu.org/binutils">https://ftpmirror.gnu.org/binutils</a>.
       Once you have the latest version's archive I recommend creating a directory in your home folder called <div class="source_code">src</div> and expanding it there.

       From there you'll want to add the following commands to your <div class="source_code">~/.profile</div>.  Once you add these, don't forget that you must 
       either source them or log out and log back in.

       <br><br>
       <div class="code_block">
           <div class="source_code">export PREFIX="$HOME/opt/cross"</div>
           <br><br>
           <div class="source_code">export TARGET=i686-elf</div>
           <br><br>
           <div class="source_code">export PATH="$PREFIX/bin:$PATH"</div>
       </div>
       <br><br>

       Now, just copy and paste the following commands from the OSDev Wiki to finish installing.  Make sure to replace x, y, and z with the version of Binutils 
       that you downloaded.

       <br><br>
       <div class="code_block">
           <div class="source_code">cd $HOME/src</div>
           <br><br>
           <div class="source_code">mkdir build-binutils</div>
           <br><br>
           <div class="source_code">cd build-binutils</div>
           <br><br>
           <div class="source_code">../binutils-x.y.z/configure --target=$TARGET \<br> --prefix="$PREFIX" \<br> 
                    --with-sysroot --disable-nls --disable-werror</div>
            <br><br>
           <div class="source_code">make</div>
           <br><br>
           <div class="source_code">make install</div>
       </div>
       <br><br>

    

        Once Binutils is all set, we can install our GCC cross-compiler.  Like before, you'll want to download the source code from <a href="https://ftp.gnu.org/gnu/gcc/">https://ftp.gnu.org/gnu/gcc</a>
        and expand it in your <div class="source_code">~/src</div> folder.  Once that's set, run the following commands (also courtesy of the OSDev Wiki).  Make sure to 
        set x, y, and z to the correct version of gcc that you downloaded.

        <br><br>
        <div class="code_block">
            <div class="source_code">cd $HOME/src</div>
            <br><br>
            <div class="source_code">which -- $TARGET-as || echo $TARGET-as is not in the PATH</div>
            <br><br>
            <div class="source_code">mkdir build-gcc</div>
            <br><br>
            <div class="source_code">cd build-gcc</div>
            <br><br>
            <div class="source_code">../gcc-x.y.z/configure --target=$TARGET \<br> --prefix="$PREFIX" --disable-nls \<br>--enable-languages=c,c++ --without-headers</div>
            <br><br>
            <div class="source_code">make all-gcc</div>
            <br><br>
            <div class="source_code">make all-target-libgcc</div>
            <br><br>
            <div class="source_code">make install-gcc</div>
            <br><br>
            <div class="source_code">make install-target-libgcc</div>
            <br><br>
        </div>
        <br><br>

        Now that your cross-compiler is installed, just add it to your PATH variable:

        <br><br>
        <div class="code_block">
            <div class="source_code">export PATH="$HOME/opt/cross/bin:$PATH" >> ~/.profile</div>
            <br><br>
            <div class="source_code">source ~/.profile</div>
        </div>
        <br><br>

        You should be able to access your compiler like the following:

        <br><br>
        <img src="images/assmToC/gccCrossVersion.PNG">
        [2]
        <br><br>

        Ok, congrats!  You successfully built a cross-compiler.  Let's jump right in and write some C code next.  
        
        <br><br>
        <h2 id="kernel_main"> C Code </h2>

        From our <span class="source_code">boot.asm</span> file, we'll jump to the symbol <span class="source_code">kernel_main</span>. 
        Thus, for now, let's put together a <a href="https://github.com/RyanStan/ConiferOS/blob/blog_tutorial/src/kernel.c">simple C file</a> that defines this symbol and does some arithmetic.

        <br><br>
        <img src="images/assmToC/kernel_main.PNG">
        <br><br>

        To reiterate, our goal is to compile this code, add it to our raw disk image, and load it into memory and jump to it from 
        our bootloader.  
        
        This brings us to an important point.  Let's compile and link this file with the default GCC linker script settings and take a look at it.
        To generate the exectuable, I'll be using the following target that I've added to my Makefile.

        <br><br>
        <img src="images/assmToC/bin_kernel.PNG">
        <br><br>

        Flags is defined as follows.  If you're curious about any of the flags I'm passing in, check out the <a href="https://linux.die.net/man/1/gcc">man page for GCC</a>.

        <br><br>
        <img src="images/assmToC/flags.PNG">
        <br><br>

        This is the output I get when I attempt to make the <span class="source_code">bin/kernel</span> target.

        <br><br>
        <img src="images/assmToC/compile_warning.PNG">
        <br><br>

        There are a couple problems with what I just did here and the second warning describes one of these.  Since the linker couldn't find the symbol <div class="source_code">_start</div>,
        it assigned it the address <span class="source_code">0x8048060</span>.  Why is the linker looking for this symbol?  Take a look at the following command and output.
        
        <br><br>
        <img src="images/assmToC/ld_default_entry.PNG">
        <br><br>

        The <span class="source_code">--verbose</span> option to our linker shows us the default linker script (which is the one that gcc uses when it calls the linker).  By piping this script to grep, we can see the line 
        <span class="source_code">ENTRY(_start)</span>.  This is the linker command for 
        defining the first executable instruction in an output file[5].  This works fine for user space programs on Linux, but it won't work in our case since we don't 
        define that symbol.  

        <br><br>

        Let's look at another instruction in the default linker script. 

        <br><br>
        <img src="images/assmToC/ld_default_out_format.PNG">
        <br><br>

        The command <span class="source_code">OUTPUT_FORMAT</span> instructs ld to format its output.  While i386 is the correct target architecture, we don't want our 
        output to be an ELF file.  Our operating system doesn't know how to execute ELF files yet, so we want the output of the linker to be a pure binary.  

        <br><br>

        There's one other problem I want to address before we write a new linker script.  Let's create a linker script that uses the correct <span class="source_code">kernel_main</span>
        symbol as the entry point, but let's leave the output format as an ELF file so we can look at the addresses of the symbols.  Our linker script will contain two lines:
        <br> <br> 
        <span class="source_code">
            ENTRY(kernel_main) <br>
            OUTPUT_FORMAT(elf32-i386)
        </span>
        <br><br>

        All I'm doing to pass the script to the linker is setting the -T option on GCC and passing in the script's path.  
        Here's the output of the <a href="https://linux.die.net/man/1/nm">nm</a> tool.

        <br><br>
        <img src="images/assmToC/symbols_no_link.PNG">
        <br><br>

        Since our linker script doesn't contain any information on where to place the different output sections in memory (text, data, bss, etc...), it just defaulted 
        to placing our <span class="source_code">kernel_main</span> symbol at address 0x00.  This isn't want we want.  Since our bootloader will load our C code into memory 
        at 1 MB, we need our linker to create addresses relative to 1 MB.  To fix this, we'll need to write our own linker script.

        <br><br>

        <div class="sideNote">
            <p>
                We'll be loading our C code into memory at 1 MB because this is where the Linux kernel loads it's protected mode code [6]. 
            </p>
        </div>


        <br><br>

    </p>

    <br><br>
    <h2 id="linker"> Writing a Linker Script </h2>

    <p>
        <div class="sideNote">
            <p>
                If you want to an introduction to linker scripts that is more in depth than I'll be covering here, I recommend 
                <a href="http://web.mit.edu/rhel-doc/3/pdf/rhel-ld-en.pdf">"Red Hat Enteprise Linux 3.  Using ld, the Gnu Linker"</a>.  I found chapter 4 was very useful.
                Especially 4.6 which is on the <span class="source_code">SECTIONS</span> command.  
            </p>
        </div>
        <br><br>
    
        I already alluded to the first two commands we'll need in our linker script, <span class="source_code">ENTRY(kernel_main)</span> and <span class="source_code">OUTPUT_FORMAT(binary)</span>.
        Next, we'll need to use the <span class="source_code">SECTIONS</span> command to describe the layout of the output file's sections.
        A section is the smallest unit of an object file that can be relocated (e.g. text, data, bss, etc...) [7].  
        Thus, the <span class="source_code">SECTIONS</span> command describes where these units will be placed in the final linked executable.  
        <br><br>

        Here's what our final linker script will look like.  I'll walk you through how everything under <span class="source_code">SECTIONS</span> works. 
        
        <br><br>
        <img src="images/assmToC/linker_script.PNG">
        <br><br>
        
        The special linker variable dot on line 5 contains the current output location counter.  This special variable can only be set under <span class="source_code">SECTIONS</span> and it 
        defaults to 0.  Since we want our <span class="source_code">.text</span> section to start at 1 MB in memory, as this is where our bootloader will put our code, we set the location counter to 
        1 M.  Line 6 defines the output section <span class="source_code">.text</span>.  Line 8 specifies that all <span class="source_code">.text</span> sections from all input files should be placed into this output section.  
        The location counter automatically increases by the size of the text section.  However, since we call <span class="source_code">ALIGN(4096)</span> on the output section, we ensure that the 
        location counter is moved to an address that is aligned with 4096 bytes.  This is the alignment that GCC expects when it compiles code.  
        After this point you'll notice that we don't assign the dot variable again.  We're ok with each other section being relatively placed to the text section.  
        <br><br>
        Lastly, I made sure to create an output section <span class="source_code">.asm</span> for assembly code.  This is just an abitrarily named section that will be useful 
        for keeping compiled C code separate from assembly code.  
        <br><br>
        Now that we have an idea of how this linker script works, let's use it to generate an executable. 
        Here is the updated rule I'm using to create the kernel binary with our compiled C code. 

        <br><br>
        <img src="images/assmToC/bin_kernel_linked.PNG">
        <br><br>
        
        Next, we'll want to load this code into memory and execute it.  Time to do some
        more work with our bootloader.

    </p>

    <br><br>
    <h2 id="loading"> Loading Our Kernel into Memory </h2>

    <p>
        Let's update our Makefile and append our kernel binary onto our disk image.  To do this, we can 
        update the <span class="source_code">bin/disk.img</span> rule.  
        
        <br><br>
        <img src="images/assmToC/disk_img_final.PNG">
        <br><br>

        The command <a href="https://man7.org/linux/man-pages/man1/dd.1.html">dd</a> can be used to
        copy raw data.  Here, we're using it to build up our disk image.  On line 11, bin/disk.img is created 
        as an exact copy of bin/boot.bin.  This disk image is 512 bytes, or one hard disk sector.  
        Then on line 12 we append the contents of our kernel code to the second sector of our disk image.
        On line 13 we read from /dev/zero which is a special file that provides null characters [8].
        The values we've passed to the parameters bs and count make it so that we append 512 bytes of null characters, 100 times, 
        to our disk image.  This is just a fancy way of making our hard disk image larger so it can simulate a real hard disk.
        It also ensures that the second sector of our image is completely filled up, that way no errors occur when we copy 
        the kernel code into memory.
        <br><br>

        Now it's time to load our kernel from the disk image into memory.  As I mentioned earlier,
        we'll be loading our kernel at 1 MB, as this is where Linux loads its protected mode kernel code.
        We'll be loading and jumping to our kernel from a place in our bootloader 
        where we're already in protected mode.  This makes things a bit tricker because we can't access the 
        BIOS routines anymore.  Specifically, we can't use BIOS interrupt 0x13. This 
        is the routine for sector-based hard disk reads and writes using 
        cylinder-head-sector (CHS) addressing [9].  
        Instead, we'll have to write a driver to communicate with the external hard disks 
        through the CPU's I/O instructions.

        <br><br>

        If we look at the man page for 
        <a href="https://manpages.debian.org/stretch/qemu-system-x86/qemu-system-i386.1.en.html">our QEMU emulator</a>,
        we'll see that it lists the peripherals it simulates.

        <br><br>
        <img src="images/assmToC/qemu_peripherals.PNG">
        <br><br>

        Of interest to us is <i>2 PCI IDE interfaces with hard disk and CD-ROM support</i>.
        These are the storage devices that QEMU is emulating.  Our raw disk image will be located on hard drive 0.
        IDE stands for Integrated Device Electronics, but
        it's more commonly known as ATA (Advanced Technology Attachment). 
        These are standard physical interfaces for connecting storage device like hard drives to the motherboard.
        In IDE or ATA devices, the actual hard drive controller is built right into the hard drive.  This is the controller 
        circuit which will enable us to communicate with the hard drive from the CPU.
        We can communicate with this controller by using the IO instructions of the CPU [10].

        <br><br>
        <div class="sideNote">
            <p>
                <b>What's the difference between ATA and IDE?</b>
                IDE was the name of the original specification.  However, as the standard broadened to
                include things like CD-ROMS, ATA was standardized.  Therefore, all ATA devices conform to the 
                IDE standard [11].
                <br><br>
                <b>From Wikipedia:</b>
                The first version of what is now called the ATA/ATAPI interface was developed by 
                Western Digital under the name Integrated Drive Electronics (IDE). --ADD CITATION #10--
            </p>
        </div>
        <br><br>
        
        The ATA interface defines registers and commands that the disk controller understands so that we can 
        interact with the hard drive.  <a href="http://users.utcluj.ro/~baruch/media/siee/labor/ATA-Interface.pdf">This document</a> describes the registers and commands.
        We'll be using a few of these commands in our code.
        <br><br>

        It's also important to be aware of  
         <a href="https://en.wikipedia.org/wiki/Logical_block_addressing">logical block addressing</a>.
        LBA is defined in the ATA standard and is an improved way of addressing blocks.  With CHS addressing,
        blocks of a disk are referred to by a tuple consisting of a cylinder, a head, and a sector.
        However, with LBA addressing, each block is referred to by a simple index.  This makes things much easier 
        for us (the programmers).

        <br><br>
        Here's the code I use to interact with the hard disk and to load our kernel into memory.
        For brevity, I won't describe the code in detail here.  Instead, you should check out the comments
        that I wrote alongside it.
        Once again, I'll mention that this code is derived from 
        <a href="https://www.udemy.com/course/developing-a-multithreaded-kernel-from-scratch/">Daniel McCarthy's Operating System course on Udemy</a>, 
        and it is publically available on his <a href="https://github.com/nibblebits/PeachOS">Github page</a>.

        <br><br>
        
        <a href="https://github.com/RyanStan/ConiferOS/blob/6f06b60ee2f4382ee6ee26610421d4ce492419c3/src/boot/boot.asm#L88">
            Check out <span class="source_code">load_kernel</span> in my bootloader on Github.
        </a>

    </p>

    <br><br>
    <h2 id="gdb"> Using GDB to Make Sure Things Worked </h2>

    <p>
        At this point, things <i>should</i> be working.  We need to make sure that this is the case and that our code has entered 
        the <span class="source_code">kernel_main</span> function in <span class="source_code">kernel.c</span>.  If we had a print function, we could just print to the terminal from 
        <span class="source_code">kernel_main</span> and we would know that things were working.  Instead, since this isn't the case, we'll use GDB 
        remote debugging to step through our code and make sure things are working as expected.
        <br><br>
        QEMU supports gdb's remote-connection facility via <a href="https://man7.org/linux/man-pages/man1/gdbserver.1.html">gdbserver</a>.  
        This allows us to remotely debug the code that QEMU is executing. 
        I'll walk you through how to do this.

        <br><br>

        First, we'll want to update our Makefile so that the compilation and linking of <span class="source_code">kernel.c</span> to <span class="source_code">kernel.bin</span>
        are done in two separate steps.  We want 
        access to <span class="source_code">kernel.o</span>, the intermediary object file, because GDB can load in the symbol table from this file, which will make debugging easier for us.  
        This will allow us to set breakpoints in our <span class="source_code">kernel.c</span> code by referring to symbols like <span class="source_code">kernel_main</span>.  
        Here is my additional Makefile rule for <span class="source_code">build/kernel.o</span>:

        <br><br>
        <img src="images/assmToC/kernel_targets.PNG">
        <br><br>

        <a href="https://github.com/RyanStan/ConiferOS/blob/blog_tutorial/Makefile">Here is my final Makefile</a>.

        <br><br>

        Next, install Tmux (if you don't already have it) and create split panes (ctrl+b then %).  In one pane, run the following command:

        <br><br>
        <span class="source_code">qemu-system-i386 -s -S -drive file=bin/disk.img,index=0,media=disk,format=raw</span> 
        <br><br>

        The -s option opens a gdbserver on the QEMU machine at TCP port 1234.   
        The -S option makes sure that the CPU doesn't start immediately.  This allows us to start the CPU from our local gdb session so that we don't miss anything.  
        <br><br>

        Now, in our other pane, run gdb.  Here are the first two commands you'll use inside gdb:

        <br><br>
        <span class="source_code">
            add-symbol-file build/kernel.o 0x100000
            <br>
            target remote localhost:1234
        </span>
        <br><br>

        The first command adds the symbol table from <span class="source_code">kernel.o</span> to our debugging session.  
        The argument <span class="source_code">0x100000</span> is just the memory address at which 
        the file's text section will be loaded, so 1 MB in our case.  The second command connects the gdb session to the gdbserver running inside QEMU.
        
        <br><br>

        Here is what your terminal should look like.  

        <br><br>
        <img src="images/assmToC/start_debugging.PNG">
        <br><br>

        Next, set a breakpoint in <span class="source_code">kernel_main</span> and then run continue.  You should hit the breakpoint.
        If you do, that means your bootloader correctly loaded your <span class="source_code">kernel.bin</span> file into memory and jumped to it.  Congrats!
        Here's a screenshot of me hitting the breakpoint, and then stepping through the code in <span class="source_code">kernel.c</span> and printing out the local variables. 

        <br><br>
        <img src="images/assmToC/gdb_things_working.PNG">
        <br><br>

    </p>

    <br><br>
    <h2 id="conclusion">Conclusion</h2>
    <p>
        I was always amazed and confused by the startup stages of the Linux Kernel.  How the Kernel goes from pure assembly, to C code, was always a mystery to me.    
        I had so many questions when I started writing my own operating system.  Doesn't compiled C code rely on the Linux Kernel for startup routines and memory management?  
        How does the linker know where in memory to place certain symbols?  Does the OS tell the linker where to put these symbols?  If so, how?

        <br><br>
        
        These were just some of the questions I had.  However, now I realize that things 
        aren't as complicated as I once thought.  In summary, to go from assembly to C code, you must

        <ul>
            <li>compile your C code with a properly configured cross-compiler </li>
            <li>write a linker script that (a) properly aligns your sections with where you C code will be loaded into memory and that (b) outputs a binary file instead of an ELF file</li>
            <li>use the ATA interface to load your code into a fixed point in memory and jump to it from your bootloader</li>
        </ul>

        And that's it!  I hope you enjoyed this article.  If you have any questions or any feedback, feel free to reach out to me at ryanstan@vt.edu.

    </p>

    <br><br>
    <h2 id="referenceHeader">References</h2>

    <ul class="references">
        <li>[1] 	"Boot Sequence," OSDev Wiki, 18 September 2020. [Online]. Available: https://wiki.osdev.org/Boot_Sequence. [Accessed 29 July 2921].</li>
        <li>[2] 	"GCC Cross-Compiler," OSDev Wiki, 15 February 2021. [Online]. Available: https://wiki.osdev.org/GCC_Cross-Compiler. [Accessed 29 July 2021].</li>
        <li>[3] 	"Why do I need a Cross Compiler?," OSDev Wiki, 10 December 2019. [Online]. Available: https://wiki.osdev.org/Why_do_I_need_a_Cross_Compiler%3F. [Accessed 29 July 2021].</li>
        <li>[4]     "Installing GCC: Building," 28 July 2021. [Online]. Available: https://gcc.gnu.org/install/build.html. [Accessed 2021 July 2021].</li>
        <li>[5] 	"The Entry Point," The GNU Project, [Online]. Available: https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_24.html. [Accessed 29 July 2021].</li>
        <li>[6] 	D. P. Bovet and M. Cesati, "System Startup," in Understanding the Linux Kernel, Third Edition, O'Reilly Media, Inc., 2005. </li>
        <li>[7] 	"Sections - IA-32 Assembly Language Reference Manual," Oracle, [Online]. Available: https://docs.oracle.com/cd/E19455-01/806-3773/elf-3/index.html. [Accessed 2 August 2021].</li>
        <li>[8] 	"/dev/zero," Wikipedia, 23 April 2021. [Online]. Available: https://en.wikipedia.org/wiki//dev/zero. [Accessed 2 August 2021].</li>
        <li>[9] 	"INT 13H," Wikipedia, 22 June 2021. [Online]. Available: https://en.wikipedia.org/wiki/INT_13H. [Accessed 2 August 2021].</li>
        <li>[10] 	"Parallel ATA," Wikipedia, 25 July 2021. [Online]. Available: https://en.wikipedia.org/wiki/Parallel_ATA. [Accessed 2 August 2021].</li>
        <li>[11] 	"What's the difference between ATA, PATA, and IDE?," Stack Exchange, 30 September 2011. [Online]. Available: https://superuser.com/questions/341452/whats-the-difference-between-ata-pata-and-ide. [Accessed 2 August 2021].</li>
    </ul>


    TODO: need to go back and change all references to qemu-x86 to qemu-i686 (--done--)
          redo split screen pictures (--done--)
          change my makefile at one point to not output an object file when I'm exploring with nm (--done--)
          fill in citations (-- done--)
          make sure links point to correct places
          update comments in my ata code

    </div></body></html>